\documentclass[en, 11pt, xcolor=dvipsnames]{beamer}
\usepackage[en]{infocoBeamer}

\definecolor{hrefcol}{RGB}{0, 0, 255} % Example: blue color

% -------------------------------------------------------------------------------------
\usepackage{tikz}
\usetikzlibrary{shapes.callouts, shadows, calc}
\usepackage{listings}

%\usepackage{fontspec-xetex}

\tikzset{note/.style={rectangle collout, rounded corners,fill=grap!20, drop shadow, font=\footnotesize}}

\newcommand{\tikzmark}[1]{\tikz[overlay,remember picture] \node (#1) {};}    

\newcounter{image}
\setcounter{image}{1}

\makeatletter
\newenvironment{btHighlight}[1][]
{\begingroup\tikzset{bt@Highlight@par/.style={#1}}\begin{lrbox}{\@tempboxa}}
{\end{lrbox}\bt@HL@box[bt@Highlight@par]{\@tempboxa}\endgroup}

\newcommand\btHL[1][]{%
  \begin{btHighlight}[#1]\bgroup\aftergroup\bt@HL@endenv%
}
\def\bt@HL@endenv{%
  \end{btHighlight}%   
  \egroup
}

\newcommand{\bt@HL@box}[2][]{%
  \tikz[#1]{%
    \pgfpathrectangle{\pgfpoint{0pt}{0pt}}{\pgfpoint{\wd #2}{\ht #2}}%
    \pgfusepath{use as bounding box}%
    \node[anchor=base west,rounded corners, fill=green!30,outer sep=0pt,inner xsep=0.2em, inner ysep=0.1em,  #1](a\theimage){\usebox{#2}};
  }%
   %\tikzmark{a\theimage} <= can be used, but it leads to a spacing problem
   % the best approach is to name the previous node with (a\theimage)
 \stepcounter{image}
}
\makeatother

%\setmainfont{FiraCode Nerd Font Mono}
%\setsansfont{FiraCode Nerd Font Mono}
%\setmonofont{FiraCode Nerd Font Mono}

%\setCJKmainfont[BoldFont = STLibian-SC-Regular,]{TpldKhangXiDictTrial}
%\setCJKsansfont{DFWaWaSC-W5}
%\setCJKmonofont{STXingkai-SC-Light}
%\setCJKfamilyfont{qingsong}{FZQKBYSJW--GB1-0}
%\lstset{language=Java,
%        basicstyle=\footnotesize\ttfamily,
%        keywordstyle=\footnotesize\color{blue}\ttfamily,
%        moredelim=**[is][\bthl]{`}{`},
%}

\lstset{
  basicstyle            =   \scriptsize\ttfamily,          % 基本代码风格
    keywordstyle        =   \bfseries,          % 关键字风格
    commentstyle        =   \scriptsize\tt\itshape,  % 注释的风格，斜体
    stringstyle         =   \tt\itshape,  % 字符串风格
    flexiblecolumns,                % 别问为什么，加上这个
    numbers             =   left,   % 行号的位置在左边
    showspaces          =   false,  % 是否显示空格，显示了有点乱，所以不现实了
    numberstyle         =   \ttfamily,    % 行号的样式，小五号，tt等宽字体
    showstringspaces    =   false,
    captionpos          =   t,      % 这段代码的名字所呈现的位置，t指的是top上面
    frame               =   lrtb,   % 显示边框
}

\lstdefinestyle{Java}{
    language        =   Java,
    commentstyle    =   \scriptsize\color{red}\ttfamily,
    basicstyle      =   \scriptsize\ttfamily,
    keywordstyle    =   \scriptsize\color{blue}\bfseries,
    keywordstyle    =   [2] \color{teal},
    stringstyle     =   \scriptsize\color{magenta}\tt,
    numberstyle     =   \tiny\ttfamily,
    showstringspaces=   false,
    flexiblecolumns,                % 别问为什么，加上这个
    breaklines      =   true,   % 自动换行，建议不要写太长的行
    columns         =   fixed,  % 如果不加这一句，字间距就不固定，很丑，必须加
    basewidth       =   0.15cm,
		moredelim       =   **[is][\btHL]{`}{`},
    captionpos      =   t,      % 这段代码的名字所呈现的位置，t指的是top上面
    frame           =   lrtb,   % 显示边框
}
% -------------------------------------------------------------

% meta-data
\title{Java Programming Language \\ Simple Guide} % The short title in the optional parameter appears at the bottom of every slide, the full title in the main parameter is only on the title page
\subtitle{Infoco Programming Classes} % Presentation subtitle, remove this command if a subtitle isn't required
\author{Ug. Sihang Sha \and Pg. Muxi Qiao} % Presenter name(s), the optional parameter can contain a shortened version to appear on the bottom of every slide, while the main parameter will appear on the title slide
\institute{Xiann' Jiaotong Livepool University \\ \smallskip \textit{infoco@xjtlu.edu.cn}} % Your institution, the optional parameter can be used for the institution shorthand and will appear on the bottom of every slide after author names, while the required parameter is used on the title slide and can include your email address or additional information on separate lines
\date{\today} % Presentation date or conference/meeting name, the optional parameter can contain a shortened version to appear on the bottom of every slide, while the required parameter value is output to the title slide

%-------------------------------------------------------------------------------------------------------

% document body
% ------------------------------------------------------------------------------------------------------
\begin{document}

\maketitle

% ------------------------------------------------------------------------------------------------------

% -----------------------------------------------

%------------------------------------------------
\section{Variables, And Type of Variables}
\begin{frame}[fragile]
	\frametitle{Variables}

	%% Contents:
	%
	% 变量是我们在Java编程中最常遇到的东西. 
	%
	% 大家想一下, 计算机之所以被称作计算机,
	% 核心就在于计算两字, 而Java作为一门计算机编程语言,
	% 则提供了数以百计的对数据进行操作, 运算的方法
	%
	% 这些东西当然可以对我们写在纸面上的量,
	% 字面量(或立即值, in assembly), 进行计算, 比如 1+2
	% 但是, 就像数学的函数一样,
	% 如果只提供一个固定量, 是没有意义的
	% 这时候, 就必须要有变量来代替固定值了
	%
	% 本次的主要内容是详细讲解于变量相关的内容

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			Variables are something we manipulate in Java often.\\

			As we mentioned last class, variable can store values, do algebra operations and draw value stored inside them for use then.

			\begin{columns}[c]
				\begin{column}{0.4\textwidth}

					literal (or immediate, in assembly)

					\begin{lstlisting}
2147483647
0x7fffffff
017777777777
1.0
2e4\end{lstlisting}

				\end{column}

				\begin{column}{0.4\textwidth}

					variable(Definition, in Java)

					\begin{lstlisting}
int foo = 2147483647;
int bar = -2147483648;
double real = 1.0;
double var = 3e1;\end{lstlisting}

				\end{column}
			\end{columns}

		\end{column}
	\end{columns}

\end{frame}

\subsection{Data, and Variables which are assigned data}
\begin{frame}[fragile]
	\frametitle{Data, and Variables which are assigned data}

	%% Contents:
	%
	% 变量是一个容器, 而它需要承装的则是 "数据"
	% 如我们刚才展示的各种整数实数,
	% 乃至于之前所介绍过的字符串
	% 这样的一些存储了信息的量, 就都可以是我们口中的 "数据"
	%
	% 我们再次以之前的 "Hello, World!" 程序为例,
	% 这个程序中, 哪些东西是数据呢?
	% 答案是 那个 "Hello, World!" 的字符串,
	% 它承载的就是这样你好世界的一个信息
	%
	% 不过大家请注意, 这个字符串, 实际上本身不是数据
	% 而是我们在前面提到了的 "字面量",
	% 那么这些我们可以直接在程序中写下的字面量,
	% 又是什么东西呢?
	% 它实际上是数据的一种表现形式, 叫值
	% 而数据是一种抽象的概念, 需要一些其他的方式来代表, 操作
	% 所以有了值这种东西, 来代表某些数据.
	% 因此, 从这个方面来看, 单独的值本身没有意义
	%
	% 而在后面, 我们也将接触除了这些可以被直接写出的 "值" 以外的对数据的表示方法
	% 
	% 不过直接写出值并无法对其进行更进一步的操作,
	% 因此也就有了变量
	% 变量, 之前已经讲过, 是一种容器,
	% 大家从直观上可以看出, 编程的变量和数学上的变量有着千丝万缕的联系
	% 比如大家可以看一下PPt上的这个示例
	%
	% 这里分别是数学中的函数和Java中的函数
	% 它们干的事情是相似的,
	% 用一个参数调用它, 并且产出一个值
	% 就像函数的定义, 对于集合X中的值, 在集合Y上的映射
	% x是函数的自变量, 产出则是因变量
	%
	% 不过, 在程序设计中, 变量的作用更进一步, 它可以承载一个值,
	% 也可以被重新赋值为其他的值,
	% 它可以作为函数的自变量
	% 也可以在函数求值的过程中被定义,
	% 承载其他表达式(可以与数学中的表达式, 或函数同等理解)的结果
	%

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			{\scriptsize
				{
					Data, is something we manipulate in programming and contains some information.\\

					Value, is one represent for data.\\

					Variables, are some containers that hold those data.
					Or, officially, a variable is a named unit of data that is assigned a value.
				}
			}

			\begin{columns}[c]
				\begin{column}{0.5\textwidth}
					{\large
						\[
							f(x) = x^2 + x - 8
						\]
					}
				\end{column}
				\begin{column}{0.5\textwidth}
					\begin{lstlisting}[style=Java]
int f(int x){
  return x * x + x - 8;
}\end{lstlisting}

					\begin{lstlisting}[style=Java]
int d = f(8);
// which is same as
int g = 8 * 8 + 8 - 8;
// or, even
int a = 8;
int y = a * a + a - 8;\end{lstlisting}
				\end{column}
			\end{columns}

		\end{column}
	\end{columns}

\end{frame}

\subsection{Variable, Definition of variables}
\begin{frame}[fragile]
	\frametitle{Definition for variables}

	%% Contents:
	% 
	% 大家早在上节课, 其实就以接触到变量的定义了
	% 不过, 在这次课中, 我们将详细讲解变量定义的方式,
	% 以及其相关的含义.
	%
	% 不过呢, 当然不包括命名规范啦
	% 毕竟在上一节课就已经讲的很清楚了
	%
	% 大家可以看到ppt上展示的第一个部分的东西
	% 展示了变量定义的规则
	% 不过可能同学们不太看得懂这些符号表示的意思,
	% 所以大家可以看下面,
	%
	% 首先, 第一行, 我们干的事情是定义了一个变量foo,
	% 这个变量的类型是int, 这里的int代表, 变量类型.
	% 后续我门将会详细讲解变量类型和变量的关系
	%
	% 注意哦, 这里和我们之前写的都不一样
	% 只是定义了变量, 而没有给它赋值
	% 当我们需要使用这个变量的时候,
	% 如果直接使用而未给它赋值, 就会出现问题
	% 只会得到它的默认值
	% 因为变量类型是int, 而int的默认值为0,
	% 所以, 如果后续不对它重新赋值,
	% 直接使用的话, 我们会得到结果0
	% 不同的变量类型会又不同的初值,
	% 不过这些将会在后面详细说明
	%
	% 下面一行, 类似的方式, 我们定义了一个int类型的变量,
	% bar, 但是与第一行不同的是, 我们在定义变量的同时,
	% 给了它一个初始的值, 这里, 这个值是10
	% 像这样对变量进行定义, 并赋初值的行为, 叫做变量的初始化.
	% 在定义变量的时候初始化是一个很好的习惯
	% 哪怕就是希望变量被初始化为0, 或者它们的默认值
	%
	% 变量也可以连续定义, 并且连续初始化
	% 就像下面两行中, 对于double类型的变量的定义

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}
<Type-Identifier> <Variable-Name> [= <Initial-Value>];
// OR
<Type-Identifier> <Variable-Name> [= <Initial-Value>]
                [, <Variable-Name> [= <Initial-Value>]]
                [,...]
                ...;
// <...> means compent and its meaning
// [...] means following parts are optional\end{lstlisting}

			\begin{lstlisting}[style=Java]
int foo;      // define a variable called foo
int bar = 10; // define a variable, whose initial value is 10 and called bar
// Above we define each variable in a single line
double a,b;   // define two variable, one is a, and the other is b
double read = 1.0, pi = 3.14;
double alpha = 1.0, beta = 3.6, theta = 9.9;\end{lstlisting}

		\end{column}
	\end{columns}

\end{frame}

% --------------------------------------------------------

\subsection{Type of variables, and values}
\begin{frame}[fragile]
	\frametitle{Variable Type}
	% TODO: And brief introduce to class, object and instance
	% (类, 对象 和实例)
	%
	%% Contents:
	% 大家或许会注意到,
	% 我们在上一页的ppt中提到了int型, double型等字词
	% 这些其实就是变量的类型,
	%
	% 在现实生活中, 数据实际上是有类型的
	% 比如说, 这里有50个同学, 这个数据一定是个整数对吧,
	% 不会出现50.5个同学这种表述
	% 不然, 咱们这就不是编程课, 是犯罪现场了
	%
	% 而当我们去银行取钱, 则又要考虑到精度在2位小数的实数了
	% 因为除了$1 或 $20,这种, 也会有5cent或者更小的金额
	% 这时候, 如果还用整数表示, 就势必会造成误差
	% 这在涉及到交易的环境下是完全无法被接受的
	%
	% 同时, 数据不止需要有数字,
	% 有时候也需要用字符表示,
	% 比如我们的hello world, 这是没有办法用以实数, 乃至虚数来表达的
	% 这些就又需要字符和字符串类型
	%
	% 在计算机中, 有关于数据的差异更大, 相对应的也有各种不同的限制
	% 如 int只能表示从-2147483648~2147483647之间的数
	% 而 Byte甚至只能表示-1024~1023之间的数
	%
	% 下表展示了我们将学习的Java中的一些基本数据类型
	% 首先是老熟人String, 如果只说英文名不太习惯的话,
	% 大家对字符串这个名称是否有印象呢
	%
	% 然后下面的四个是我们的整数类型,
	% 包含了byte, short, int, long四种, 分别对应了四种不同的范围
	% 再然后是实型数据, 或者叫做浮点型
	% 包含float和double, 它们的特点之一是数据不一定精确, 但是却可以表示极大的实数
	%
	% 再往下, 是字符型数据, 这个东西实际上组成了字符串
	% 不过我们几乎不会与它打太深的交道,
	%
	% 最后是逻辑值, 布尔型数据, 它只有一个成员, boolean
	% 不好读是么
	% 没关系, 记住就行了,
	% 在程序设计中, 我们不会太常的与它打直接交道
	% 但是我们却会在各种涉及到做与不做的判断的地方遇见它们
	%
	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\footnotesize
			\begin{table}
				\begin{tabular}{l l l}
					%\toprule
					Type      & Defination   & default Form         \\
					%\midrule
					String    & String foo;  & ""                   \\
					          &              &                      \\
					Byte      & byte foo;    & 0x0 / 0 / 00 / 0b0   \\
					Short     & short foo;   & 0x0 / 0 / 00 / 0b0   \\
					Integer   & int foo;     & 0x0 / 0 / 00 / 0b0   \\
					Long      & long foo;    & 0x0l / 0l / 00/ 0b0l \\
					          &              &                      \\
					Double    & double foo;  & 0.0d                 \\
					Float     & float foo;   & 0.0f                 \\
					          &              &                      \\
					Character & char foo;    & '$\backslash0$'      \\
					          &              &                      \\
					Boolean   & boolean foo; & false                \\

					%\bottomrule
				\end{tabular}
			\end{table}


		\end{column}
	\end{columns}

\end{frame}


% --------------------------------------------------------

\subsubsection{String, More Specified}
\begin{frame}[fragile]
	\frametitle{Methods for manipulate string}

	%% Contents:
	%
	% 作为我们第一个程序里面就涉及到的数据,
	% 字符串, 不仅被用于演示程序的执行, 在程序设计过程当中也相当有用
	%
	% 所以, 针对字符串, Java实际上提供了很多相关方法
	% 比如上一节课中讲到的字符串拼接
	%
	% 对字符串的拼接有两种方式
	% 一种是我们在上一节课就已经了解
	% 了的+号, 大家可以看到ppt的第二行
	%
	% 但是, 在拼接字符串的时候, 我们还有另一种方式
	% 就是concatnate方法
	% 大家可以看到ppt上绿色高亮的部分
	% 这样一个跟在对象后面, 以点开头的东西, 就是方法的调用
	%
	% 大家或许会注意到, 这里提到了 "对象", 和 "方法", 两个概念
	% 这里是两个涉及到了Java深层设计的东西,
	% 我们将在后面的课程中详细讲解
	%
	% 正如之前所说的,
	% 如1234这样的直观上的数值是数据的一种表现形式,
	% 对象则是数据的另一种表现形式,
	% 它将与某些事物有关的东西全都放在一起,
	% 形成一个被称作 "类" 的组织关系
	% 类可以被认为是对于一些事物共有属性的概括
	% 比如说, 我们可以用"猫" 来统称所有的缅因猫, 暹罗猫等各个品种的猫
	% 用 "狗" 来统称所有的会汪汪叫, 有鼻子有眼四足行走的生物
	% 但是, 由于类其实是将我们之前提到的这些整数或者其他的数据,
	% 我们称之为 "基本数据" 用一些方式组织起来,
	% 所以, 几乎所有的用于基本数据的操作,
	% 都没有办法直接应用于类的 "实例" 上面
	% 不过, 具体这个类是什么, 有哪些用处,
	% 以及, 常用类的用法, 我们将在后续的课程中慢慢揭示...
	%
	% 大家现在只要暂时将这些或存入变量,
	% 或直接写下的值(或数据)视为对象,
	% 而这些像绿色高亮部分一样直接对对象进行的操作视作方法就可以了
	%
	% 大家再可以看一下, System.out.println, 中的println,
	% 是不是也是这样的呢, 实际上println也是一个 "方法"
	%
	% 好的, 现在回归主题
	% 大家可以将ppt上的示例实际运行一下试试
	%
	% 我们预期看到的应该是
	% "This is Java, Java is best."
	% "This is Rust, Rust is better."
	% "This is C, they all my kids."
	% (Write it onto the white board)
	%
	% 大家其实从这里就可以看出来,
	% 字符串的拼接实际上不会对原来的字符串有任何更改
	% 而是创建了一个新的字符串
	%
	% 所以, 如果想要修改一个字符串变量的内容, 应该要怎么做?
	% 用赋值符号将其覆盖掉

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}[style=Java]
String str = "String";
str + "foo"; // will produce "Stringfoo"
str`.concat("bar")`; // will produce "Stringbar"
"String".concat("bar"); // will produce "Stringbar"\end{lstlisting}


			\begin{lstlisting}[style=Java]
pubic class StringConcate{
  public static void main(String [] args){
    String str = "This is ";
    System.out.println(str.concat("Java, Java is best."));
    System.out.println(str + "Rust, Rust is better.");
    // + will do same as .concat
    System.out.println("This is ".concat("C, they all my kids."));
    System.out.println(str);
  }// ! main
}\end{lstlisting}


		\end{column}
	\end{columns}

\end{frame}

\begin{frame}[fragile]

	%% Contents:
	% 
	% 对于一个字符串, 实际上还可以有一些其他的操作
	% 比如, 我们可以通过charAt方法获得字符串中某一个字符
	% 也可以用length方法来获得字符串的长度
	% 不过一定要注意哦, charAt方法的位置是以0开始计数的,
	% 所以如果是charAt(1), 实际上得到的是第二个字符
	% 如下例中, 第二行
	%
	% 字符串也可以被比较,
	% 通过compareTo方法, 可以看出两个字符串是否相同,
	% 如果两个字符串相同, 则会返回一个0值
	% 否则, 会返回一个差值
	% 但是, 其实我们在比较字符串的时候怎么会考虑它们的字典序差异呢?
	% 在要确定是否相等时还要用类似 0 == str.compareTo(str2)的方式
	% 十分的繁琐
	% 所以我们一般会用另一个方法, equals, 来进行比较
	% 这个方法会直接返回两个字符串是否相同, 结果也不是整数值
	% 而是一个逻辑值, 这样就可以被直接用于各种判断了
	%
	% 当然, 这是在判断两个字符串里的字母是否完全一样时用的
	% 那么如果我们希望忽略大小写呢?
	% 那就需要使用compareToIgnoreCase和equalsIgnoreCase两个方法了
	%
	% 当然, 对于空字符串, 其实也有一个判断, 叫做empty
	% 这就避免了写equals("")这样的东西, 也便于理解想要做的事情
	%
	% 当然, 对于字符串的操作, 一定也少不了查找给定内容
	% 这时就需要使用indexOf方法了
	% indexOf会返回第一次找到给定字符串的位置信息,
	% 这个信息和我们提供给charAt的一样, 是个整型数
	%
	% indexOf是从左到右的搜索, 与之相对应的, 还有lastIndexOf
	\begin{columns}
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}[style=Java]
String foo = "Hello, World!";
System.out.println(foo.charAt(1)); // => e
System.out.println(foo.compareTo("hello, world!"));
System.out.println(foo.equalsIgnoreCase("hello, world!"));
System.out.println(foo.indexOf("World"));\end{lstlisting}

		\end{column}
	\end{columns}
\end{frame}

\subsubsection{Z --- Byte/Short/Integer/Long}
\begin{frame}[fragile]
	\frametitle{Integer}

	%% Contents:
	%
	% 除了字符串, 计算机既然被称作计算机, 也不可避免会需要与数字打交道,
	% 而整型数就是我们在编程中最长碰见的数字
	%
	% 在上一节课中, 我们已经了解到对于整数的一些基本操作,
	% 比如加减乘除等四则运算
	%
	% 而现在, 我们将更详细的介绍一下我们会遇见的这些整数
	%
	% 我们在上节课中, 见到了int类型
	% 但是, 实际上, 在前面的ppt中, 我们也可以看到
	% 整数一共有4的类型, 分别是byte, short, int, long,
	% 这些不同的类型, 主要差异在存储的值的多少
	% byte最小, 只能存储2^8个数, 也就是说, 从-128到+127的数
	% 其次是short, 2^16,
	% 然后就是我们最常用的int, 2^32, ~2147483648~2147483647
	% 最后是long, 2^64
	%
	% 不过这些东西太过于基础, 只能进行简单的+,-,*,/,%运算
	% 所以, 为了方便, Java将给它们做了一个包装, 使得它们可以像String 
	% 一样用多种方法被操作
	% 这些包装分别为, Byte, Short, Integer, Long,
	%
	% 不过大家要注意, 这些包装, 其实都是类,
	% 类是没有办法通过我们之前见过的各种运算符来操作和比较的
	% 而是需要用一些方法来代行
	% 不过, 对于这些基本类型的包装很简单
	% 实际上它们本身也可以被拆包得到原来的基本类型
	% 所以大家在面对这些东西的时候, 直接转会基本类型再运算就可以啦
	%
	% 而后面我们会详细讲到这些包装类需要如何操作的

	% TODO: With integer operators, like +,-,*,/,%
	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{table}
				\begin{tabular}{l l l}
					%\toprule
					Type  & Wrapper & Range                                                   \\
					%\midrule
					byte  & Byte    & $ -2^{7} ~ 2^{7} - 1 $ (-128 \dots 127)                 \\
					short & Short   & $ -2^{15} ~ 2^{15} - 1 $ (-32768 \dots 32767)           \\
					int   & Integer & $ -2^{31} ~ 2^{31} - 1 $ (-2147483648 \dots 2147483647) \\
					long  & Long    & $ -2^{63} ~ 2^{63} - 1 $ (-9,223,372,036,854,775,808    \\
					      &         & \dots 9,223,372,036,854,775,807)                        \\
					%\bottomrule
				\end{tabular}
			\end{table}

			\begin{lstlisting}[style=Java]
int foo = 10;
Integer bar = 10;
String barInString = bar.toString();
System.out.println(bar.equals(foo));
// we should use equals to compare Integers and other wrapper
System.out.println(bar.compareTo(30));\end{lstlisting}

		\end{column}
	\end{columns}

\end{frame}

\subsubsection{R --- Float/Double}
\begin{frame}[fragile]
	\frametitle{Real numbers}

	%% Contents:
	%
	% 除了整数, 计算机也可以处理实数
	%
	% 在Java中, 实数一共有两种类型, 分别为float和double
	% 我们称之为, 浮点数和双精度浮点数
	% 浮点数的表示范围远大于整数, 但是浮点数会存在精度问题, float只能处理6~7位有效数字,
	% double则会相对而言多
	%
	% 比如说, 对于float类型, 它最多一共可以精确表示16,777,216个数, 但是它却可以表示1e20这么大的数字
	%
	% 大家可以用如下所示的代码来查看它们的最大最小值
	% 其实, 整数的各个范围也是可以用类似方法来查看最大最小值的哦
	% 具体就是, 包装类 加上 .MIN_VALUE或.MAX_VALUE
	%
	% 与整数类似, 实数也可以进行各种四则运算
	% +,-,*,/
	% 并且, 和整数除法不同的是, 这里的除法并不会放弃余数, 而是会得到小数结果的哦
	% 但是请记住, 取模运算是只可以被用于整数的
	%
	% 当然, 实数也有包装类, 提供了一些方便的用于操作浮点数的方法
	% 还是如代码所示, 分别为Float和Double

	% TODO: +,-,*,/
	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}[style=Java]
// float
System.out.println("Type: float and how many bits: " + Float.SIZE);
System.out.println("Wrapper: java.lang.Float");
System.out.println("Min value: Float.MIN_VALUE = " + Float.MIN_VALUE);
System.out.println("Max value: Float.MAX_VALUE = " + Float.MAX_VALUE);
System.out.println();

// double
System.out.println("Type: double and how many bits: " + Double.SIZE);
System.out.println("Wrapper: java.lang.Double");
System.out.println("Min value: Double.MIN_VALUE = " + Double.MIN_VALUE);
System.out.println("Max value: Double.MAX_VALUE = " + Double.MAX_VALUE);
System.out.println(); \end{lstlisting}

		\end{column}
	\end{columns}

\end{frame}

\subsubsection{Big numbers --- BigInteger/BitDecimal}
\begin{frame}[fragile]
	\frametitle{Extremely large numbers}

	%% Contents:
	%
	% 虽然看上去long和double可以表示的范围已经足够大了
	% 至少适用于我们日常生活中各种数据的表示了
	%
	% 但是, 在一些特殊的场景之下, 它们还是不够大
	%
	% 这个时候, 就需要所谓的 "大数" 了,
	% Java中常用的大数有两种
	% 第一个是BigInteger, 而另一个是BigDecimal
	% 分别用于表示特大的整数和特大的小数
	% 这两个类型的使用和其他的整数或实数类型及其相似
	% 都是四则运算和一些高级功能

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}[style=Java]
BigInteger foo = new BigInteger(1);
BigDecimal bar = new BigDecimal(0.1);
// Large numbers created through int or float type
// may cause some unexpedted conditions
System.out.println("Value of foo is: " + foo);
System.out.println("Value of bar is: " + bar);
// We use String to construct them instead
foo = new BigInteger("9223372036854775809");
bar = new BigDecimal("0.1");
System.out.println("Value of bar is: " + bar);\end{lstlisting}

		\end{column}
	\end{columns}

\end{frame}

\begin{frame}[fragile]

	%% Contents:
	%
	% 如何创建一个数倒是已经了解了,
	% 但是要如何对它们进行操作呢?
	% 同学们可能会直观想要直接用类似整数类型和实数类型相似的
	% +,-,*,/,或者, 整数类型特有的%, 来对其操作
	% 但是, 实际上这是不可行的
	% 因为这些大数, 实际上也是类,
	% 并且由于其脱离了基本类型, 如int, double,
	% 也就无法用基本类型的操作方式来操作
	% 所以
	% 我们需要用这些类的方法来操作它们
	%
	% 大家可以看到, 这里是一些比较常用的方法
	% add是将一个数与另一个相加
	% compareTo则是相减
	% mutiply相乘
	% devide相除
	% pow乘方
	% 其实还要sqrt开方
	%
	% 当然, 和其他的基本数据的包装类一样,
	% 其实也可以用equals来比较两数是否相等
	%
	% 最后, 在代码中, 我们再次输出了foo的值,
	% 大家其实可以看到
	% foo的值是没有改变的
	% 也就是说, 这些大数和字符串一样, 是 "不变的"
	% 要想修改变量的内容,
	% 就要用结果把原来的东西给覆盖掉
	% UwU~

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}[style=Java]
BigInteger foo = BigInteger("24");
System.out.println(foo.add(BitInteger.ONE));
System.out.println(foo.compareTo(BigInteger.TWO));
System.out.println(foo.mutiply(BigInteger.TWO));
System.out.println(foo.devide(BigInteger.TWO));
System.out.println(foo.mod(BigInteger("9")));
System.out.println(foo.pow(BigInteger.TWO));
System.out.println(foo);\end{lstlisting}

		\end{column}
	\end{columns}

\end{frame}

\subsubsection{Logical --- Boolean}
\begin{frame}[fragile]
	\frametitle{Logical representation, Boolean}

	%% Contents:
	%
	% 说了这么久数值计算
	% 也该讲一讲什么是对错了
	% 其实我们生活中很常需要与对错打交道
	% 当然, 写程序也是一样
	% 而且, 计算机有一点好,
	% 就是它总是非黑即白的, 不像我们的生活那样
	% 总是需要考虑什么是不完全正确的, 而什么有需要考量
	%
	% 所以, 在计算机的生活中, 只有是与非
	% true/false
	% 当我们比较两个数字,
	% 如果它们每一位数都相同, 那么它们就一定相等
	% 那么, 一个对于它们是否相等的判断, 就是是
	% 否则, 就只会有否
	%
	% 下面, 就让我们来看一下
	% 计算机中的是与非
	%
	% 在上面的表格中, 我们以经见到了
	% boolean
	% 中文叫做布尔值, 逻辑值
	% 它表示的是一个命题是否为真
	% 比如说, 对于1等于1这个命题, 它得到的就该是true,
	% 大家可以看一下ppt上第一行, 尝试自己运行一下试试看
	% 
	% 这里就要讲到我们的关系运算了
	% 它们用于表示两个基本数值之间的关系
	% 包括了等于判断
	% 大于, 小于, 大于等于, 小于等于 和不等于判断
	%
	% 我们可以把这些判断当做各个命题
	% 如果可以满足这样一个判断, 就是真
	% 否则, 就是假
	%
	% 当然, 我们之前也提到了, 类无法用这些运算来处理
	% 但是, 实际上我们也可以看到,
	% 我们至今遇见的各个类也都提供了比较两个对象的方法
	% 而且, 我们目前为止还是主要和基本数据打交道,
	% 所有不用太担心相关的问题

	% TODO: With relationship operator like ==,<,>,>=,<=,!=, ...
	% With logical operator like ||,&&,!
	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{table}
				\begin{tabular}{l l}
					%\toprule
					Relationship             & Operator \\
					%\midrule
					Equals                   & ==       \\
					Greater than             & >        \\
					Less than                & <        \\
					Greater than or equal to & >=       \\
					Less than or equal to    & <=       \\
					Not Equal                & !=       \\
					%\bottomrule
				\end{tabular}
			\end{table}

			\begin{lstlisting}[style=Java]
System.out.println(1==1);\end{lstlisting}

		\end{column}
	\end{columns}

\end{frame}
\begin{frame}[fragile]

	%% Contents:
	%
	% 当然咯,
	% 既然其他的基本类型都有可以写出来的类型和变量定义
	% 我们的逻辑值怎么能没有呢
	% 大家可以看到ppt,
	% 这上面分别是它的基本类型定义和包装类定义
	%
	% 大家再想一想, 其他基本类型都有自己的运算规则
	% 逻辑类型是不是也要有自己的运算规则?
	%
	% 当然的,
	% 我们有所谓的逻辑运算来操作逻辑值
	% 比如说, 大家再看ppt
	% 这里就用到了 "与" 运算,
	% 来表示 1 < var < 80这样一个概念

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}[style=Java]
boolean foo = true;
Boolean bar = new Boolean(foo);\end{lstlisting}

			\begin{lstlisting}[style=Java]
int var = 20;
System.out.print(1 < var && 80 > var);\end{lstlisting}

		\end{column}
	\end{columns}

\end{frame}
\begin{frame}[fragile]

	%% Contents:
	%
	% 大家可以看到下表
	% 这里列出了这些运算符以及它们的运算规则
	% 简单来说, 就是
	% 与运算需要两边都满足, 才得到真
	% 或运算只需要一个满足, 就得到真
	% 否运算, 使得原表达式结果相反

	\begin{columns}[c]
		\begin{column}{0.98\textwidth}

			\center\scriptsize
			\begin{table}
				\begin{tabular}{l l l l l l}
					%%\toprule
					Logic & Operator & Form     & A     & B     & Result \\
					      &          &          &       &       &        \\
					%%\midrule
					And   & \&\&     & A \&\& B & true  & true  & true   \\
					      &          &          & true  & false & false  \\
					      &          &          & false & true  & false  \\
					      &          &          & false & false & false  \\
					Or    & ||       & A || B   & true  & true  & true   \\
					      &          &          & true  & false & true   \\
					      &          &          & false & true  & true   \\
					      &          &          & false & false & false  \\
					Not   & !        & ! A      & true  &       & false  \\
					      &          &          & false &       & true   \\
					%%\bottomrule
				\end{tabular}
			\end{table}

		\end{column}
	\end{columns}

\end{frame}
\begin{frame}[fragile]

	%% Contents:
	%
	% 有一点大家要注意, 就是, 逻辑运算是 "短路" 的
	% 这是什么意思呢?
	% 就是只要通过前一步操作可以确定整体的值的时候,
	% 就不会再执行后一步了
	% 比如, 当我咋执行一个与运算时,
	% 如果前面以及确定为否了,
	% 那么它就会立即将表达式的整体视为否,
	% 而不执行后一步
	% 相应的, 在执行或运算时,
	% 只要前面确定为真,
	% 则后面就不会再被执行了
	%
	% 大家还记得++运算符是用来做什么的吗?
	% ++运算符是用来让变量自身增加1的,
	% 和各种类的方法不一样,
	% 它的修改会直接反馈到变量本身
	% 所以如果后半句被执行了
	% 我们会期望a的值为6
	% 但是事实上, 我们最终只会得到a的值为5
	%
	% 大家可以试一下这个例子
	% 实际体验一下
	%
	% 不过呢, 我们并不推荐在各种复杂的语句中使用++这样的自增自减运算符
	% 而是直接把它们单列
	% 不过, 这里为了演示逻辑运算的特性, 所以这样写了
	% 本课不会详细区别两种自增运算符
	% 如果对自增运算感兴趣, 可以在网上查询资料
	% 或者在课后单独询问

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}[style=Java]
public class Logical {
  public static void main(String[] args){
    int a = 5;
    boolean b = (a<4) && (a++<10);
    System.out.println("Whole resule is " + b);
    System.out.println("while a is ... :" + a);
  } // ! main
}\end{lstlisting}

		\end{column}
	\end{columns}

\end{frame}

\subsection{Bitwise Operation, How those value be calculated in computer}
\begin{frame}[fragile]
	\frametitle{Bitwise Operation}

	%% Contents:
	% 
	% 既然已经讲到了逻辑运算, 我们干脆再深入一些
	% 讲一讲计算机运算的基础 ---
	% 位运算
	%
	% 讲到位运算, 我们要先了解一些, 有关于位的知识
	% 大家可以知道, 所有的数据,
	% 在计算机种都是通过二进制数字存储的
	% 二进制数字, 实际上和我们的十进制数字相当一致,
	% 也是有类似个位,十位,百位, 这样的不同进制位的
	% 不过由于二进制中, 只有0与1, 所以实际上
	% 并不像十进制这样有这么多的名字
	% 而是统一用多少多少位来表示
	% 比如11111, 就是一个5位二进制数
	%
	% 不过有些同学也许会注意到
	% 英文中, 表示十进制数的位数时, 用的是digit
	% 而在我们表示二进制的时候, 用的是bit
	% 这是为什么呢
	% 其实bit就是专门表示像二进制这样只有两个状态的位的
	% 是digit的一个子集表示
	%
	% 大家这也可以了解到, 中文对于位的翻译的来源
	%
	% 在计算机中
	% 由于一些历史悠久的设计问题, 或者说是文化传承
	% 我们计算机可以操作的最小的数据是8位二进制数
	% 不知大家有没有想到什么?
	% 没错, Java的Byte类型就是一个8位二进制整形
	% 那么这个Byte是什么意思呢
	% Byte表示字节, 每8位表示一个字节,
	% 所以说字节, 其实就是计算机可以操作的最小单位
	% 与之相对应的, 还有kb,mb,gb,tb,eb...
	% 1 KB(KiB) = 1024 Byte
	% 1 MB(MiB) = 1024 KB
	% 这些代换的根源实际上都来自于2^10
	%
	% 下面, 大家已经见到了Byte, 那么有没有举一反三,
	% 想到另外几个整数类型的来源?
	% 没错
	% 两个Byte的组合, 在计算机中, 被称作word, 字
	% 我们的Short型就是存储了一个字, 有16字节
	% 而后还有double word, 双字, 32字节, 用于int类型
	% quart word, 四字, 64字节, long类型
	% 最后, paragraph, 两个quart word, 128字节,
	% 大到无法被cpu直接计算
	%
	% 但是, 大家看到ppt, 既然不论Byte, short, int这些
	% 都是2的2次方幂倍大小,
	% 那么为什么它们表示的范围却只有类似
	% -2的7次方幂到2的7次方幂减1 的这种形式呢?
	% 因为为了表示符号, 计算机单独使用了一位作为符号位
	% 为0, 则是正
	% 为1, 则是负
	% 所以这些整数就只能用剩下的位数来记录数值了
	%

	% TODO: Byte, Word, Double Word,
	% Structure of IEEE 754 Float
	% sl,sr,xor,or,not(|,&,^,~,<<,>>,>>>)
	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\center{
				1 Byte = 8 bit\\
				1 KB(KiB) = $2^{10}$(1024) Byte\\
				1 MB(MiB) = $2^{10}$(1024) KB \\
				\dots
			}

			\begin{table}
				\begin{tabular}{l l}
					%\toprule
					Type        & Range                    \\
					%\midrule
					bit         & 0/1                      \\
					Byte        & 0000'0000 to 1111'1111   \\
					Word        & 0x0000 to 0xffff         \\
					Double Word & 0x00000000 to 0xffffffff \\
					Quad Word   & ...                      \\
					%\bottomrule
				\end{tabular}
			\end{table}

		\end{column}
	\end{columns}

\end{frame}
\begin{frame}[fragile]

	%% Contents:
	% 
	% 当然, 这些数据类型是有范围有长度的,
	% 但是数据却不一定按照你给的长度来
	% 万一有些时候, 一不小心加多了怎么办呢?
	% 这种情况叫做溢出,
	% 为了减小这些问题的影响, 并且方便各种运算
	% 我们为这些数值制定了
	% 原码,反码,补码的规则
	%
	% 以下, 将数据实际表示的东西称作真值, True Form
	% 原码是Sign-Mangnitude, 反码为 1's Complement Code
	% 补码为2's Complement Code
	%
	% 对于正数, 他的反码补码都为自己的原码
	% 而对于一个负数, 他的反码为原码除符号位全取反,
	% 如ppt所示, 可以看到, 对于-128, 他的反码为1000,0000
	% 而补码, 则是将它的补码加1,
	% 这样, 当我们取得了一个数的反码时,
	% 这个数的反码加上这个数的补码
	% 在忽略溢出后, 总是等于0
	% 这样, 加法和减法就可以被统一成为加法运算
	%
	% 下面是一个例子
	% 比如: 我们要让 5 + (-3) (Write them onto the write board)
	% 首先可以将它们全都转换成补码形式得到 0101, 和 1101
	% 然后, 就是对它们进行加法运算
	% 0101 + 1101 = 10010
	% 这里, 溢出一位
	% 所以我们把他抛弃掉, 最后得到0010, 值为2, 和5-3的结果一致

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{table}
				\begin{tabular}{l l l l l}
					%\toprule
					Code                & Form      & value & Form(-)   & value \\
					%\midrule
					True Form           & 0111,1111 & 127   & 1111,1111 & -128  \\
					Sign-Mangnitude     & 0111,1111 &       & 1111,1111 &       \\
					1's Complement Code & 0111,1111 &       & 1000,0000 &       \\
					2's Complement code & 0111,1111 &       & 1000,0001 &       \\
					%\bottomrule
				\end{tabular}
			\end{table}

		\end{column}
	\end{columns}

\end{frame}
\begin{frame}[fragile]

	%% Contents:
	% 
	% 不过, 不确定大家是否有曾对浮点数的误差有所疑惑?
	%
	% 实际上, 这是由于我们计算机中对于浮点数的表示导致的问题
	%
	% 我们目前一直使用ieee 754 标准来表示浮点数
	% 它规定 浮点数的值是用 V = (-1) ^ s * M * 2^E 这个公式来计算的
	% 这也就导致
	% 当我们希望表示的数据过大时,
	% 它会逐渐变得越来越宽泛, 越来越不精确
	%
	% 如下所示, 这里就是一个32位的浮点数
	% 由此可以看到, 它的符号位占了一位, 用以表示数据的正负
	% exponent表示它的次幂, 也就是公式中E的部分
	% fraction则是基数, 也就是公式中的M
	%

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\[
				V = (-1)^{S} * M * 2^E
			\]

			\begin{table}
				\begin{tabular}{l l l}
					%\toprule
					Sign   & exponent & fraction                \\
					%\midrule
					0      & 01111100 & 01000000000000000000000 \\
					1 bits & 8 bits   & 23 bits                 \\
					%\bottomrule
				\end{tabular}
			\end{table}

		\end{column}
	\end{columns}

\end{frame}
\begin{frame}[fragile]

	%% Contents:
	% 
	% 既然讲解了大多数类型的表示方法,
	% 现在也该要讲解一下什么是位运算了
	%
	% 实际上, 位运算和逻辑运算极其相似
	% 毕竟, 大家可以想一想
	% 逻辑运算处理的是真, 假两个值
	% 而计算机中的一位也只有0,1两种表示
	% 所以它们的运算是很有借鉴意义的
	%
	% 大家可以看到这里的and, 和or
	% 和逻辑运算里的两个\&, 两个|很像是不是
	% 它们其实就是位运算中的与与或
	% 它们对每个数字, 按照位数, 取得结果

	\begin{columns}[c]
		\begin{column}{0.98\textwidth}

			\begin{table}
				\begin{tabular}{l l l l l l l}
					%\toprule
					Operation     & Operator   & Form           & A    & B    & n & Example \\
					%\midrule
					And           & \&         & A \& B         & 1010 & 1100 &   & 1000    \\
					Or            & |          & A | B          & 1010 & 1100 &   & 1110    \\
					Xor           & $\string^$ & A $\string^$ B & 1010 & 1100 &   & 0110    \\
					Negative      & $\sim$     & $\sim$ A       & 1010 &      &   & 0101    \\
					              &            &                &                           \\
					Shift left    & < <        & A < < n        & 1010 &      & 2 & 10/1000 \\
					Shift right   & > >        & A > > n        & 1010 &      & 1 & 1101/0  \\
					SHR (no sign) & > > >      & A > > > n      & 1010 &      & 1 & 0101/0  \\
					%\bottomrule
				\end{tabular}
			\end{table}
			* SHR is a short cut for Shift right

		\end{column}
	\end{columns}

\end{frame}


%------------------------------------------------

\subsection{Variable Assignment --- Cover origin value, or ``set a value for variable''}
\begin{frame}[fragile]
	\frametitle{Variable Assignment}

	%% Contents
	%
	% 既然讲过了变量的定义, 我们也要重新讲一下变量的赋值
	%
	% 其实在上一节课中, 我们已经简单讲过变量赋值相关的东西了
	% 不知到大家是否还有印象呢
	%
	% 现在, 我们了解到了,
	% 在Java中不止有我们在第一节课中讲到过的基本数据
	% 也有各种类
	%
	% 那么对于类型为某个类的变量进行赋值操作会是什么样的呢?
	% 实际上和其他的基本类型很像, 都是用=号
	% 直接将原始值覆盖掉
	%
	% 但是与其他的基本数据不同的是, 
	% 类变量只能用=赋值, 而无法用复合赋值的方式来赋值
	% 毕竟, 既然连+,-,*,/,的这些运算都没有办法进行,
	% 在赋值的时候又怎么来复合这些运算呢?
	%
	% 下面我们再次将它们提出来看一下
	% 这里是各种复合运算符的运算规律
	%
	% 大家可以看到, 实际上在用复合赋值的时候,
	% 我们的结果实际上是被进行过各种转换的
	% 而这里就涉及到了自动类型类型转换规则了

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}[style=Java]
int foo = 20;
foo += 4; // same as foo = foo + 4;
System.out.println(foo); // which should output 24
byte bar = 9;
bar -= 1; // same as bar = (byte)(bar - 1);
System.out.println(bar); // => 8
long var = 7;
var *= 9; // same as var = var * 9l;
System.out.println(var); // => 63\end{lstlisting}

		\end{column}
	\end{columns}

\end{frame}

\subsection{Calculate --- Auto Type Conversion}
\begin{frame}[fragile]
	\frametitle{Type Conversion}

	% Cast from one to another
	%% Contents:
	% 
	% 自动类型转换是在Java进行运算的时候会发生的,
	% 将较小的类型转换为较大类型的行为
	%
	% 比如, 在对short和byte类型变量进行运算的时候,
	% 会默认将运算结果视为int类型,
	% 而在涉及到long类型的运算时, 则会将其提升至long
	% 这种行为, 我们将其称为类型提升
	%
	% 具体规则可以看到下表
	% 
	% 当一方的类型在该表中处于较高位置时
	% 整个表达式运算的结果就会被提升到该类型

	% TODO: Integer.parseInt
	% String.toString
	% ...
	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			{\center
				{
					Low  ------------------------------------> High

					byte,short,char —> int —> long —> float —> double
				}
			}

			\bigskip %

			Each operand on higher position will resule whole
			expression returns a value in its type

			byte,short and char are exception,
			any calculation between them will cause a answer whose type is int

		\end{column}
	\end{columns}

\end{frame}

\subsection{Calculate --- Explicit Type Conversion}
\begin{frame}[fragile]


	%% Contents:
	% 
	% 当然, 既然有自动类型转换, 当然也有 "手动" 的
	% 我们将其称为显示类型转换, 或者强制类型转换
	%
	% 具体就是如该表所示
	% 用一个括号括住想要转换成为的类型, 后面跟上表达式
	%
	% 但是要注意, 任何的类型转换都有可能会导致精度缺失
	% 比如在这个例子当中,
	% 我们在将一个实数转换成为整数的时候
	% 就会抛弃掉它的小数部分
	%
	% 对了, 不知大家有没有注意到这里定义float变量的时候
	% 给它初始化的值的末尾带上了一个f?
	% 这里的f就是用来标记前面的数是一个float类型浮点数的
	% 因为在Java中, 默认写出的浮点数都是double类型的
	% 
	% 而整数中, 其实也有一个类似的需求
	% 就是long, 因为整数的默认类型为int,
	% 所以当我们需要写出long类型值的时候,
	% 就需要在它的末尾加上一个l
	%
	% 大家可以手动操作试一下

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}[style=Java]
float var = 12.89f;
int bar = (int) var;
System.out.println(var);
System.out.println(bar);\end{lstlisting}

			f in `12.89f' is a conversion, aims to tell the java compiler
			that the number is a float, rather than double.\\

			l in `31l' is same, tell the compiler that the number is a long type
			integer, rather than a int one.

		\end{column}
	\end{columns}

\end{frame}
\begin{frame}[fragile]

	%% Contents:
	% 
	% 既然基本数据类型的转换是这个样子,
	% 那么根据之前的经验,
	% 非基本数据类型是不是就没法用这种方式转换类型了?
	%
	% 答案几乎是肯定的
	% 那么对于String和整型数, 浮点型数的交换, 要怎么做?
	%
	% 大家看到代码
	% 我们可以用如ppt所示的方式来将它们转换
	% 很方便对吧
	%
	% 不过不同的类, 互相转换的方式也不同,
	% 所以, 我们会在遇见需要转换数据的时候在单独讲解的呢

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}[style=Java]
String str = "123";
int foo = Integer.parseInt(str);
str = "1.23";
double bar = Double.parseDouble(str);
      \end{lstlisting}

		\end{column}
	\end{columns}

\end{frame}

%------------------------------------------------

\section{Input \& Output}
\begin{frame}[fragile]
	\frametitle{Input and Outputs}

	%% Contents:
	% 
	% 将了这么多变量的知识
	% 那么也要讲一讲, 如何使得这个 "变量", 真正的可变起来
	%
	% 我们想要在程序运行的时候查看信息, 或者传入一些数据
	% 依赖的是输入和输出
	%
	% 没有错哦, 这可不是什么废话, 就是输入和输出
	% 在Java中, 分别给了输入和输出两种方式操作
	% 也就是, 将输入操作, 和输出操作, 归类成了两个 "类"
	% 我们在处理输入输出的时候, 就是依赖着它提供给我们的这两个类的
	%
	% 不过啦, 我们目前还不会接触到那么复杂的用法啦
	% 
	% 我们的输入和输出都是通过一种叫做 "流" 的方式来读取或者输出的
	% 当我们想要输出什么的时候, 我们就逐个写出,
	% 当数据源源不断的时候
	% 我们观察它, 就会发现, 输出就像水流一样,
	% 逐个蹦出来, 而绵绵不断
	% 这就是 "流" 的直观理解
	%

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}
System.in.println("Hello, World!");
// An Example for Input\end{lstlisting}

			Data are printed in the form of stream.

			stream is just like water, you may get some of it,
			and it will flow without being interrupted.


		\end{column}
	\end{columns}

\end{frame}

\subsection{System.in / System.out}
\begin{frame}[fragile]

	%% Contents:
	%
	% 我们会在程序里面经常碰到的是System.in和System.out这两个对象
	% 它们都分别是上述类的实例之一
	%
	% 从它们名字前面的点可以看出来
	% 它们实际上属于System类, 是一些与系统相关的东西
	% System.in实际上是所谓的 "标准输入"
	% 它是我们所有程序都默认会带有的一个输入
	% 我们在终端中输入的任何字符都会被这个输入接收
	% 类似的, System.out实际上是 "标准输出"
	% 他输出的东西默认会显示在终端, 也就是我们会见到的黑框框, 中
	%
	% 大家可以看到ppt上所示的代码
	% 并且尝试运行一下
	%
	% 当这个程序运行起来以后
	% 应当会 "卡" 在那里
	% 直到我们用键盘输入什么, 并且敲下回车以后, 才会输出一个值
	% 这个值, 会是你输入的第一个字母

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}[style=Java]
import java.io.*;

pulic class Read {
  public static void main(String[] args) throws IOException {
    byte[] c = new byte[1];
    System.in.read(c);
    // Input someting here when the program is running
    System.out.println((char)c[0]);
  }
}\end{lstlisting}

		\end{column}
	\end{columns}

\end{frame}

\subsection{System.out.print*}
\begin{frame}[fragile]

	%% Contents:
	%
	% 虽然我们是第一次接触输入,
	% 但是, 我们其实早就已经和输出打各种交道了
	% 从第一节课中的hello world
	% 到前面各页ppt中的例子, 都有着println的影子
	% println就是我们最常用到的输出方法之一
	%
	% 实际上, 对于输出
	% 我们有各种以print balabala命名的方法
	%
	% 大家可以看到表格
	% 这里展示了print, println, printf
	% 它们分别表示, 输入, 输出并换行, 和格式化输出

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}[style=Java]
public class IOStream{
  public static void main(String[] args){
    System.out.print("Hello, ");
    // This will not truncate the line
    System.out.println("World!");
    // But this one will
    System.out.printf("Format out put a intget: \%d $\backslash$n", 21);
    // And this one can control how should a data be printed
  }
}\end{lstlisting}

			Each element in format string provided for printf looks like this:\\

			{\verb- %[argument\_index$][flags][width][.precision]conversion -}

			It seems to complex?\\

			Don't worry\dots


		\end{column}
	\end{columns}

\end{frame}
\begin{frame}[fragile]

	%% Contents:
	%
	% 大家可以看到下表, 这个表格展示了我们可以使用的控制字串,
	% 以及它们的效果

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\center\footnotesize
			\begin{table}[c]
				\begin{tabular}[c]{l l l l}
					Conversion & Description         & Example        & Output                   \\
					\hline
					\%s        & string              & ("\%s", "str") & str                      \\
					\%c        & character           & ("\%c", 'c')   & c                        \\
					\%b        & boolean             & ("\%b", true)  & true                     \\
					\%d        & decimal integer     & ("\%d", 12)    & 12                       \\
					\%x        & hexdecimal integer  & ("\%h", 10)    & 0xa                      \\
					\%o        & octeciaml integer   & ("\%o", 8)     & 010                      \\
					\%f        & float               & ("\%f", 1.0)   & 1.0                      \\
					\%a        & float in hexdecimal & ("\%a", 1.0)   & 0x1.0                    \\
					\%e        & scienfic notation   & ("\%a", 1.0)   & 1.0e+0                   \\
					\%g        & gernal float        &                &                          \\
					\%h        & hash code           &                &                          \\
					\%\%       & per cent note       & ("\%\%")       & \%                       \\
					\%n        & new line            & ("\%n")        & same as $"\backslash n"$ \\
					\%tm       & time type           &                &                          \\
					\%td       &                     &                &                          \\
					\hline
				\end{tabular}
			\end{table}

		\end{column}
	\end{columns}

\end{frame}

\subsection{java.util.Scanner}
\begin{frame}[fragile]

	%% Contents:
	%
	% 大家既然已经简单了解过了输入
	% 也要学习一下怎么样输出
	%
	% 在上面的例子当中, 我们可以发现, 输入的使用要比输出繁琐的多
	% 所以, 我们一般不会直接使用System.in对象
	% 而是使用各种的辅助功能
	%
	% 大家看下面的代码
	% 我们的高亮行, 定义了一个叫做input的变量
	% 这个变量是什么呢?
	% 它其实也是一个对象, 主要用于从标准输入中获取一些数据
	% 毕竟, 大家看它的类型, Scanner
	% 扫描仪
	% 大概也可以猜出它的作用
	%
	% 这个对象有很多的成员方法
	% 但是我们常用的却只有几个
	% 第一个, 就是下面一行展示的
	% nextInt方法, 它的作用, 是从输入中找到一个整数, 并且返回出来
	% 这个返回出来的值, 就可以被赋给任何你想要的int类型变量
	% 类似的, 还有一个nextDouble方法, 与nextInt相似,
	% 唯一的区别就是它主要用于获取浮点数
	% 而看到它的名字, 也可以知道, 它返回的应该是个double类型
	%
	% 下面, 就到了next方法和nextLine方法
	% 这里的两个方法都是用于获取字符串的
	% next获取到的会是一串任意的字符串,
	% 只要遇见空格或者任何其他的分隔符就会截止
	% 而nextLine则会读取直到遇见回车
	% 这两个的差异大约就像print和println吧
	%

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}[style=Java]
import java.util.Scanner;

public class InputDemo {
  public static void main(String[] args) {
    `Scanner input = new Scanner(System.in)`;

    int a = input.nextInt();
    String foo = input.next();
    foo = input.nextLine();

    input.close();
  } // ! main
}\end{lstlisting}

		\end{column}
	\end{columns}

\end{frame}

%------------------------------------------------

\section{if \dots else \dots --- execute according given condition}
\begin{frame}[fragile]
	\frametitle{If \dots and else \dots}

	%% Contents:
	%
	% 我们有了变量, 有了逻辑运算, 也可以确实使得变量变化了
	% 现在也该要讲一讲分支语句了
	%
	% 分支语句, 之所以会被称为分支语句
	% 一大原因就是它使得代码的执行可以走向不同的方向了
	%
	% 大家或许见过流程图吧
	% 我们的程序也完全可以用流程图来表示
	% 程序从一个起点开始执行
	% 经过了分支语句, 它就变成两条路径了
	%
	%                     * Beginner
	%                     |
	%                     |
	%                     branch sentence
	%                    /\
	%                   /  \
	%                  /    \
	%                 /      \
	%                |        |
	%                |        |
	%                * dosth1 * dosth2
	%                |       /
	%                |      /
	%                |     /
	%                |    /
	%                |   /
	%                |  /
	%                | /
	%                * end
	% (draw on the write board)
	%
	% 我们这节课将讲解我们最常用的一种分支语句
	% if...else语句
	%
	% 大家可以看到这里的一个例子
	% 大家比对一下这个流程图, 这个程序和这个流程图的大体逻辑是否是一致的呢?
	%

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}[style=Java]
import java.util.Scanner;

public class IfElse {
  public static void main(String[] args) {
    Scanner input = new Scanner(System.in);

    int val = input.nextInt();

    if((val % 2) == 0){
      System.out.println("Input is even");
    } else {
      System.out.println("Input is odd");
    }
  }
}\end{lstlisting}

		\end{column}
	\end{columns}

\end{frame}

\subsection{Logical operation --- when shall it be executed}
\begin{frame}[fragile]
	\frametitle{If statement is true, then?}

	%% Contents:
	%
	% If ... else ... 语句分为两个部分
	% 第一个部分就是if(statement) then部分
	%
	% 大家可以看到, 我们这个语句有个statement部分
	% 这里要写入的就是我们的命题, 如果命题可以成立, 也就是说,
	% 逻辑运算的结果为true, 就会执行then-part
	%
	% 当然, statement部分如果是boolean类型的变量也是可以的
	% 毕竟, 这里实际上检查的只是值是否为true嘛~
	% UwU
	%

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}[style=Java]
if(<statement>){
    <then-part>*
}\end{lstlisting}

			\begin{lstlisting}[style=Java]
if(true){
  System.out.println("statement is true");
}\end{lstlisting}

		\end{column}
	\end{columns}

\end{frame}

\subsection{Logical operation --- and what else if the condition is not true}
\begin{frame}[fragile]
	\frametitle{What else shall it do if statement is wrong?}

	%% Contents:
	%
	% 另一个部分就是else部分了
	% 如果statement得到了一个false值怎么办呢?
	% 如果没有else部分, 程序就会忽略
	% 而有了else部分, 程序就会去尝试执行这个else部分
	% else是和if相关联的, 没有if就没有else语句
	%

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}

			\begin{lstlisting}[style=Java]
if(...){
    ...
} else {
    <else-part>*
}\end{lstlisting}

		\end{column}
	\end{columns}

\end{frame}

% -----------------------------------------------------------------------------------------

\section{while --- how to execute some sentences once or more}
\begin{frame}[fragile]
	\frametitle{When we need to execute something repeatedly\dots}

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}


		\end{column}
	\end{columns}

\end{frame}

\subsection{Loop --- while condition do something}
\begin{frame}[fragile]
	\frametitle{Loop, loop, loop, nested loop}

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}


		\end{column}
	\end{columns}

\end{frame}

\subsubsection{Loop --- do something and check wether to continue}
\begin{frame}[fragile]
	\frametitle{Loop Rounds}
	\framesubtitle{Important to remember that code are executed linearly}

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}


		\end{column}
	\end{columns}

\end{frame}

\subsubsection{Break --- Jump out of the loop}
\begin{frame}[fragile]
	\frametitle{Jump, out of the loop!}

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}


		\end{column}
	\end{columns}

\end{frame}

\subsubsection{Continue --- Next circle}
\begin{frame}[fragile]
	\frametitle{Next circle, next round, but the same loop}

	\begin{columns}[c]
		\begin{column}{0.9\textwidth}


		\end{column}
	\end{columns}

\end{frame}

% ----------------------------------------------------------------------

\QApage

% ----------------------------------------------------------------------

\section{Referencing}

\begin{frame}
	\frametitle{Citing References}

	\bigskip % Vertical whitespace

\end{frame}

% ----------------------------------------------------------------------

\begin{frame}
	\frametitle{Acknowledgements}

	\begin{columns}[t] % The "c" option specifies centered vertical alignment while the "t" option is used for top vertical alignment
		\begin{column}{0.45\textwidth} % Left column width
		\end{column}
		\begin{column}{0.5\textwidth} % Right column width
		\end{column}
	\end{columns}
\end{frame}

\end{document}
